#Так как образа под наше приложение нет (в отличии от postgres), делаем его сами
#Описываем как создать образ с нашим приложением и запустить его

#Сборка приожения
#Нужна JDK+OS. Но так как базовый образ JDK собирался на основе какого то образа, то он явно уже содержит OS
#указываем, в какой корневой (базовый) образ поместим образ нашего приложения (после ":" - тег - версия образа)
FROM openjdk:17-jdk
#метка - никак не влияет на производительность, просто инфо
LABEL mainteiner="nikstroganov"
#указываем рабочую директорию, то есть каталог внутри docker образа
WORKDIR /app


#Запуск приложения



#инструкция, которая позволяет создать слой во время сборки образа
#можно прописывать в exec- (в виде json) или shell-форме (в данном случае shell)
RUN mkdir /app/config
#копируем файлы из target в docker образ
#все файлы, которые имеют расширение .jar копируем в app, назовем его внутри контейнера app.jar
COPY target/*.jar /app/app.jar
#какой порт используем внутри образа
#если хочешь взаимодействовать с приложение внутри образа - открой порт 8080
#на основе tcp реализован http, который мы используем в rest-запросах (альтернатива - udp). По умолчанию - tcp
EXPOSE 8080/tcp
#какую команду следует запустить из докер образа
#если написать в одну строку, то докер все равно разобьет на такой вид
ENTRYPOINT ["java", "-jar", "/app/app.jar"]